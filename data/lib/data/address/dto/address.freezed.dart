// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'address.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Address _$AddressFromJson(Map<String, dynamic> json) {
  return _Address.fromJson(json);
}

/// @nodoc
mixin _$Address {
  String get address_name => throw _privateConstructorUsedError;
  String get region_1depth_name => throw _privateConstructorUsedError;
  String get region_2depth_name => throw _privateConstructorUsedError;
  String get region_3depth_name => throw _privateConstructorUsedError;
  String get mountain_yn => throw _privateConstructorUsedError;
  String get main_address_no => throw _privateConstructorUsedError;
  String get sub_address_no => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AddressCopyWith<Address> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressCopyWith<$Res> {
  factory $AddressCopyWith(Address value, $Res Function(Address) then) =
      _$AddressCopyWithImpl<$Res, Address>;
  @useResult
  $Res call(
      {String address_name,
      String region_1depth_name,
      String region_2depth_name,
      String region_3depth_name,
      String mountain_yn,
      String main_address_no,
      String sub_address_no});
}

/// @nodoc
class _$AddressCopyWithImpl<$Res, $Val extends Address>
    implements $AddressCopyWith<$Res> {
  _$AddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address_name = null,
    Object? region_1depth_name = null,
    Object? region_2depth_name = null,
    Object? region_3depth_name = null,
    Object? mountain_yn = null,
    Object? main_address_no = null,
    Object? sub_address_no = null,
  }) {
    return _then(_value.copyWith(
      address_name: null == address_name
          ? _value.address_name
          : address_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_1depth_name: null == region_1depth_name
          ? _value.region_1depth_name
          : region_1depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_2depth_name: null == region_2depth_name
          ? _value.region_2depth_name
          : region_2depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_3depth_name: null == region_3depth_name
          ? _value.region_3depth_name
          : region_3depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      mountain_yn: null == mountain_yn
          ? _value.mountain_yn
          : mountain_yn // ignore: cast_nullable_to_non_nullable
              as String,
      main_address_no: null == main_address_no
          ? _value.main_address_no
          : main_address_no // ignore: cast_nullable_to_non_nullable
              as String,
      sub_address_no: null == sub_address_no
          ? _value.sub_address_no
          : sub_address_no // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AddressCopyWith<$Res> implements $AddressCopyWith<$Res> {
  factory _$$_AddressCopyWith(
          _$_Address value, $Res Function(_$_Address) then) =
      __$$_AddressCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String address_name,
      String region_1depth_name,
      String region_2depth_name,
      String region_3depth_name,
      String mountain_yn,
      String main_address_no,
      String sub_address_no});
}

/// @nodoc
class __$$_AddressCopyWithImpl<$Res>
    extends _$AddressCopyWithImpl<$Res, _$_Address>
    implements _$$_AddressCopyWith<$Res> {
  __$$_AddressCopyWithImpl(_$_Address _value, $Res Function(_$_Address) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address_name = null,
    Object? region_1depth_name = null,
    Object? region_2depth_name = null,
    Object? region_3depth_name = null,
    Object? mountain_yn = null,
    Object? main_address_no = null,
    Object? sub_address_no = null,
  }) {
    return _then(_$_Address(
      address_name: null == address_name
          ? _value.address_name
          : address_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_1depth_name: null == region_1depth_name
          ? _value.region_1depth_name
          : region_1depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_2depth_name: null == region_2depth_name
          ? _value.region_2depth_name
          : region_2depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_3depth_name: null == region_3depth_name
          ? _value.region_3depth_name
          : region_3depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      mountain_yn: null == mountain_yn
          ? _value.mountain_yn
          : mountain_yn // ignore: cast_nullable_to_non_nullable
              as String,
      main_address_no: null == main_address_no
          ? _value.main_address_no
          : main_address_no // ignore: cast_nullable_to_non_nullable
              as String,
      sub_address_no: null == sub_address_no
          ? _value.sub_address_no
          : sub_address_no // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Address implements _Address {
  _$_Address(
      {required this.address_name,
      required this.region_1depth_name,
      required this.region_2depth_name,
      required this.region_3depth_name,
      required this.mountain_yn,
      required this.main_address_no,
      required this.sub_address_no});

  factory _$_Address.fromJson(Map<String, dynamic> json) =>
      _$$_AddressFromJson(json);

  @override
  final String address_name;
  @override
  final String region_1depth_name;
  @override
  final String region_2depth_name;
  @override
  final String region_3depth_name;
  @override
  final String mountain_yn;
  @override
  final String main_address_no;
  @override
  final String sub_address_no;

  @override
  String toString() {
    return 'Address(address_name: $address_name, region_1depth_name: $region_1depth_name, region_2depth_name: $region_2depth_name, region_3depth_name: $region_3depth_name, mountain_yn: $mountain_yn, main_address_no: $main_address_no, sub_address_no: $sub_address_no)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Address &&
            (identical(other.address_name, address_name) ||
                other.address_name == address_name) &&
            (identical(other.region_1depth_name, region_1depth_name) ||
                other.region_1depth_name == region_1depth_name) &&
            (identical(other.region_2depth_name, region_2depth_name) ||
                other.region_2depth_name == region_2depth_name) &&
            (identical(other.region_3depth_name, region_3depth_name) ||
                other.region_3depth_name == region_3depth_name) &&
            (identical(other.mountain_yn, mountain_yn) ||
                other.mountain_yn == mountain_yn) &&
            (identical(other.main_address_no, main_address_no) ||
                other.main_address_no == main_address_no) &&
            (identical(other.sub_address_no, sub_address_no) ||
                other.sub_address_no == sub_address_no));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      address_name,
      region_1depth_name,
      region_2depth_name,
      region_3depth_name,
      mountain_yn,
      main_address_no,
      sub_address_no);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AddressCopyWith<_$_Address> get copyWith =>
      __$$_AddressCopyWithImpl<_$_Address>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AddressToJson(
      this,
    );
  }
}

abstract class _Address implements Address {
  factory _Address(
      {required final String address_name,
      required final String region_1depth_name,
      required final String region_2depth_name,
      required final String region_3depth_name,
      required final String mountain_yn,
      required final String main_address_no,
      required final String sub_address_no}) = _$_Address;

  factory _Address.fromJson(Map<String, dynamic> json) = _$_Address.fromJson;

  @override
  String get address_name;
  @override
  String get region_1depth_name;
  @override
  String get region_2depth_name;
  @override
  String get region_3depth_name;
  @override
  String get mountain_yn;
  @override
  String get main_address_no;
  @override
  String get sub_address_no;
  @override
  @JsonKey(ignore: true)
  _$$_AddressCopyWith<_$_Address> get copyWith =>
      throw _privateConstructorUsedError;
}

TotalAddress _$TotalAddressFromJson(Map<String, dynamic> json) {
  return _TotalAddress.fromJson(json);
}

/// @nodoc
mixin _$TotalAddress {
  RoadAddress? get road_address => throw _privateConstructorUsedError;
  Address? get address => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TotalAddressCopyWith<TotalAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TotalAddressCopyWith<$Res> {
  factory $TotalAddressCopyWith(
          TotalAddress value, $Res Function(TotalAddress) then) =
      _$TotalAddressCopyWithImpl<$Res, TotalAddress>;
  @useResult
  $Res call({RoadAddress? road_address, Address? address});

  $RoadAddressCopyWith<$Res>? get road_address;
  $AddressCopyWith<$Res>? get address;
}

/// @nodoc
class _$TotalAddressCopyWithImpl<$Res, $Val extends TotalAddress>
    implements $TotalAddressCopyWith<$Res> {
  _$TotalAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? road_address = freezed,
    Object? address = freezed,
  }) {
    return _then(_value.copyWith(
      road_address: freezed == road_address
          ? _value.road_address
          : road_address // ignore: cast_nullable_to_non_nullable
              as RoadAddress?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RoadAddressCopyWith<$Res>? get road_address {
    if (_value.road_address == null) {
      return null;
    }

    return $RoadAddressCopyWith<$Res>(_value.road_address!, (value) {
      return _then(_value.copyWith(road_address: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res>? get address {
    if (_value.address == null) {
      return null;
    }

    return $AddressCopyWith<$Res>(_value.address!, (value) {
      return _then(_value.copyWith(address: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TotalAddressCopyWith<$Res>
    implements $TotalAddressCopyWith<$Res> {
  factory _$$_TotalAddressCopyWith(
          _$_TotalAddress value, $Res Function(_$_TotalAddress) then) =
      __$$_TotalAddressCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({RoadAddress? road_address, Address? address});

  @override
  $RoadAddressCopyWith<$Res>? get road_address;
  @override
  $AddressCopyWith<$Res>? get address;
}

/// @nodoc
class __$$_TotalAddressCopyWithImpl<$Res>
    extends _$TotalAddressCopyWithImpl<$Res, _$_TotalAddress>
    implements _$$_TotalAddressCopyWith<$Res> {
  __$$_TotalAddressCopyWithImpl(
      _$_TotalAddress _value, $Res Function(_$_TotalAddress) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? road_address = freezed,
    Object? address = freezed,
  }) {
    return _then(_$_TotalAddress(
      road_address: freezed == road_address
          ? _value.road_address
          : road_address // ignore: cast_nullable_to_non_nullable
              as RoadAddress?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TotalAddress implements _TotalAddress {
  _$_TotalAddress({required this.road_address, required this.address});

  factory _$_TotalAddress.fromJson(Map<String, dynamic> json) =>
      _$$_TotalAddressFromJson(json);

  @override
  final RoadAddress? road_address;
  @override
  final Address? address;

  @override
  String toString() {
    return 'TotalAddress(road_address: $road_address, address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TotalAddress &&
            (identical(other.road_address, road_address) ||
                other.road_address == road_address) &&
            (identical(other.address, address) || other.address == address));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, road_address, address);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TotalAddressCopyWith<_$_TotalAddress> get copyWith =>
      __$$_TotalAddressCopyWithImpl<_$_TotalAddress>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TotalAddressToJson(
      this,
    );
  }
}

abstract class _TotalAddress implements TotalAddress {
  factory _TotalAddress(
      {required final RoadAddress? road_address,
      required final Address? address}) = _$_TotalAddress;

  factory _TotalAddress.fromJson(Map<String, dynamic> json) =
      _$_TotalAddress.fromJson;

  @override
  RoadAddress? get road_address;
  @override
  Address? get address;
  @override
  @JsonKey(ignore: true)
  _$$_TotalAddressCopyWith<_$_TotalAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

RoadAddress _$RoadAddressFromJson(Map<String, dynamic> json) {
  return _RoadAddress.fromJson(json);
}

/// @nodoc
mixin _$RoadAddress {
  String get address_name => throw _privateConstructorUsedError;
  String get region_1depth_name => throw _privateConstructorUsedError;
  String get region_2depth_name => throw _privateConstructorUsedError;
  String get region_3depth_name => throw _privateConstructorUsedError;
  String get road_name => throw _privateConstructorUsedError;
  String get underground_yn => throw _privateConstructorUsedError;
  String get main_building_no => throw _privateConstructorUsedError;
  String get sub_building_no => throw _privateConstructorUsedError;
  String get build_name => throw _privateConstructorUsedError;
  String get zone_no => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RoadAddressCopyWith<RoadAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoadAddressCopyWith<$Res> {
  factory $RoadAddressCopyWith(
          RoadAddress value, $Res Function(RoadAddress) then) =
      _$RoadAddressCopyWithImpl<$Res, RoadAddress>;
  @useResult
  $Res call(
      {String address_name,
      String region_1depth_name,
      String region_2depth_name,
      String region_3depth_name,
      String road_name,
      String underground_yn,
      String main_building_no,
      String sub_building_no,
      String build_name,
      String zone_no});
}

/// @nodoc
class _$RoadAddressCopyWithImpl<$Res, $Val extends RoadAddress>
    implements $RoadAddressCopyWith<$Res> {
  _$RoadAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address_name = null,
    Object? region_1depth_name = null,
    Object? region_2depth_name = null,
    Object? region_3depth_name = null,
    Object? road_name = null,
    Object? underground_yn = null,
    Object? main_building_no = null,
    Object? sub_building_no = null,
    Object? build_name = null,
    Object? zone_no = null,
  }) {
    return _then(_value.copyWith(
      address_name: null == address_name
          ? _value.address_name
          : address_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_1depth_name: null == region_1depth_name
          ? _value.region_1depth_name
          : region_1depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_2depth_name: null == region_2depth_name
          ? _value.region_2depth_name
          : region_2depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_3depth_name: null == region_3depth_name
          ? _value.region_3depth_name
          : region_3depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      road_name: null == road_name
          ? _value.road_name
          : road_name // ignore: cast_nullable_to_non_nullable
              as String,
      underground_yn: null == underground_yn
          ? _value.underground_yn
          : underground_yn // ignore: cast_nullable_to_non_nullable
              as String,
      main_building_no: null == main_building_no
          ? _value.main_building_no
          : main_building_no // ignore: cast_nullable_to_non_nullable
              as String,
      sub_building_no: null == sub_building_no
          ? _value.sub_building_no
          : sub_building_no // ignore: cast_nullable_to_non_nullable
              as String,
      build_name: null == build_name
          ? _value.build_name
          : build_name // ignore: cast_nullable_to_non_nullable
              as String,
      zone_no: null == zone_no
          ? _value.zone_no
          : zone_no // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RoadAddressCopyWith<$Res>
    implements $RoadAddressCopyWith<$Res> {
  factory _$$_RoadAddressCopyWith(
          _$_RoadAddress value, $Res Function(_$_RoadAddress) then) =
      __$$_RoadAddressCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String address_name,
      String region_1depth_name,
      String region_2depth_name,
      String region_3depth_name,
      String road_name,
      String underground_yn,
      String main_building_no,
      String sub_building_no,
      String build_name,
      String zone_no});
}

/// @nodoc
class __$$_RoadAddressCopyWithImpl<$Res>
    extends _$RoadAddressCopyWithImpl<$Res, _$_RoadAddress>
    implements _$$_RoadAddressCopyWith<$Res> {
  __$$_RoadAddressCopyWithImpl(
      _$_RoadAddress _value, $Res Function(_$_RoadAddress) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address_name = null,
    Object? region_1depth_name = null,
    Object? region_2depth_name = null,
    Object? region_3depth_name = null,
    Object? road_name = null,
    Object? underground_yn = null,
    Object? main_building_no = null,
    Object? sub_building_no = null,
    Object? build_name = null,
    Object? zone_no = null,
  }) {
    return _then(_$_RoadAddress(
      address_name: null == address_name
          ? _value.address_name
          : address_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_1depth_name: null == region_1depth_name
          ? _value.region_1depth_name
          : region_1depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_2depth_name: null == region_2depth_name
          ? _value.region_2depth_name
          : region_2depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      region_3depth_name: null == region_3depth_name
          ? _value.region_3depth_name
          : region_3depth_name // ignore: cast_nullable_to_non_nullable
              as String,
      road_name: null == road_name
          ? _value.road_name
          : road_name // ignore: cast_nullable_to_non_nullable
              as String,
      underground_yn: null == underground_yn
          ? _value.underground_yn
          : underground_yn // ignore: cast_nullable_to_non_nullable
              as String,
      main_building_no: null == main_building_no
          ? _value.main_building_no
          : main_building_no // ignore: cast_nullable_to_non_nullable
              as String,
      sub_building_no: null == sub_building_no
          ? _value.sub_building_no
          : sub_building_no // ignore: cast_nullable_to_non_nullable
              as String,
      build_name: null == build_name
          ? _value.build_name
          : build_name // ignore: cast_nullable_to_non_nullable
              as String,
      zone_no: null == zone_no
          ? _value.zone_no
          : zone_no // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RoadAddress implements _RoadAddress {
  _$_RoadAddress(
      {required this.address_name,
      required this.region_1depth_name,
      required this.region_2depth_name,
      required this.region_3depth_name,
      required this.road_name,
      required this.underground_yn,
      required this.main_building_no,
      required this.sub_building_no,
      required this.build_name,
      required this.zone_no});

  factory _$_RoadAddress.fromJson(Map<String, dynamic> json) =>
      _$$_RoadAddressFromJson(json);

  @override
  final String address_name;
  @override
  final String region_1depth_name;
  @override
  final String region_2depth_name;
  @override
  final String region_3depth_name;
  @override
  final String road_name;
  @override
  final String underground_yn;
  @override
  final String main_building_no;
  @override
  final String sub_building_no;
  @override
  final String build_name;
  @override
  final String zone_no;

  @override
  String toString() {
    return 'RoadAddress(address_name: $address_name, region_1depth_name: $region_1depth_name, region_2depth_name: $region_2depth_name, region_3depth_name: $region_3depth_name, road_name: $road_name, underground_yn: $underground_yn, main_building_no: $main_building_no, sub_building_no: $sub_building_no, build_name: $build_name, zone_no: $zone_no)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RoadAddress &&
            (identical(other.address_name, address_name) ||
                other.address_name == address_name) &&
            (identical(other.region_1depth_name, region_1depth_name) ||
                other.region_1depth_name == region_1depth_name) &&
            (identical(other.region_2depth_name, region_2depth_name) ||
                other.region_2depth_name == region_2depth_name) &&
            (identical(other.region_3depth_name, region_3depth_name) ||
                other.region_3depth_name == region_3depth_name) &&
            (identical(other.road_name, road_name) ||
                other.road_name == road_name) &&
            (identical(other.underground_yn, underground_yn) ||
                other.underground_yn == underground_yn) &&
            (identical(other.main_building_no, main_building_no) ||
                other.main_building_no == main_building_no) &&
            (identical(other.sub_building_no, sub_building_no) ||
                other.sub_building_no == sub_building_no) &&
            (identical(other.build_name, build_name) ||
                other.build_name == build_name) &&
            (identical(other.zone_no, zone_no) || other.zone_no == zone_no));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      address_name,
      region_1depth_name,
      region_2depth_name,
      region_3depth_name,
      road_name,
      underground_yn,
      main_building_no,
      sub_building_no,
      build_name,
      zone_no);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RoadAddressCopyWith<_$_RoadAddress> get copyWith =>
      __$$_RoadAddressCopyWithImpl<_$_RoadAddress>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RoadAddressToJson(
      this,
    );
  }
}

abstract class _RoadAddress implements RoadAddress {
  factory _RoadAddress(
      {required final String address_name,
      required final String region_1depth_name,
      required final String region_2depth_name,
      required final String region_3depth_name,
      required final String road_name,
      required final String underground_yn,
      required final String main_building_no,
      required final String sub_building_no,
      required final String build_name,
      required final String zone_no}) = _$_RoadAddress;

  factory _RoadAddress.fromJson(Map<String, dynamic> json) =
      _$_RoadAddress.fromJson;

  @override
  String get address_name;
  @override
  String get region_1depth_name;
  @override
  String get region_2depth_name;
  @override
  String get region_3depth_name;
  @override
  String get road_name;
  @override
  String get underground_yn;
  @override
  String get main_building_no;
  @override
  String get sub_building_no;
  @override
  String get build_name;
  @override
  String get zone_no;
  @override
  @JsonKey(ignore: true)
  _$$_RoadAddressCopyWith<_$_RoadAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

Document _$DocumentFromJson(Map<String, dynamic> json) {
  return _Document.fromJson(json);
}

/// @nodoc
mixin _$Document {
  List<TotalAddress>? get address => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DocumentCopyWith<Document> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DocumentCopyWith<$Res> {
  factory $DocumentCopyWith(Document value, $Res Function(Document) then) =
      _$DocumentCopyWithImpl<$Res, Document>;
  @useResult
  $Res call({List<TotalAddress>? address});
}

/// @nodoc
class _$DocumentCopyWithImpl<$Res, $Val extends Document>
    implements $DocumentCopyWith<$Res> {
  _$DocumentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = freezed,
  }) {
    return _then(_value.copyWith(
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as List<TotalAddress>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DocumentCopyWith<$Res> implements $DocumentCopyWith<$Res> {
  factory _$$_DocumentCopyWith(
          _$_Document value, $Res Function(_$_Document) then) =
      __$$_DocumentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<TotalAddress>? address});
}

/// @nodoc
class __$$_DocumentCopyWithImpl<$Res>
    extends _$DocumentCopyWithImpl<$Res, _$_Document>
    implements _$$_DocumentCopyWith<$Res> {
  __$$_DocumentCopyWithImpl(
      _$_Document _value, $Res Function(_$_Document) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = freezed,
  }) {
    return _then(_$_Document(
      address: freezed == address
          ? _value._address
          : address // ignore: cast_nullable_to_non_nullable
              as List<TotalAddress>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Document implements _Document {
  _$_Document({required final List<TotalAddress>? address})
      : _address = address;

  factory _$_Document.fromJson(Map<String, dynamic> json) =>
      _$$_DocumentFromJson(json);

  final List<TotalAddress>? _address;
  @override
  List<TotalAddress>? get address {
    final value = _address;
    if (value == null) return null;
    if (_address is EqualUnmodifiableListView) return _address;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Document(address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Document &&
            const DeepCollectionEquality().equals(other._address, _address));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_address));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DocumentCopyWith<_$_Document> get copyWith =>
      __$$_DocumentCopyWithImpl<_$_Document>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DocumentToJson(
      this,
    );
  }
}

abstract class _Document implements Document {
  factory _Document({required final List<TotalAddress>? address}) = _$_Document;

  factory _Document.fromJson(Map<String, dynamic> json) = _$_Document.fromJson;

  @override
  List<TotalAddress>? get address;
  @override
  @JsonKey(ignore: true)
  _$$_DocumentCopyWith<_$_Document> get copyWith =>
      throw _privateConstructorUsedError;
}

Meta _$MetaFromJson(Map<String, dynamic> json) {
  return _Meta.fromJson(json);
}

/// @nodoc
mixin _$Meta {
  int get total_count => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetaCopyWith<Meta> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaCopyWith<$Res> {
  factory $MetaCopyWith(Meta value, $Res Function(Meta) then) =
      _$MetaCopyWithImpl<$Res, Meta>;
  @useResult
  $Res call({int total_count});
}

/// @nodoc
class _$MetaCopyWithImpl<$Res, $Val extends Meta>
    implements $MetaCopyWith<$Res> {
  _$MetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total_count = null,
  }) {
    return _then(_value.copyWith(
      total_count: null == total_count
          ? _value.total_count
          : total_count // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MetaCopyWith<$Res> implements $MetaCopyWith<$Res> {
  factory _$$_MetaCopyWith(_$_Meta value, $Res Function(_$_Meta) then) =
      __$$_MetaCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int total_count});
}

/// @nodoc
class __$$_MetaCopyWithImpl<$Res> extends _$MetaCopyWithImpl<$Res, _$_Meta>
    implements _$$_MetaCopyWith<$Res> {
  __$$_MetaCopyWithImpl(_$_Meta _value, $Res Function(_$_Meta) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total_count = null,
  }) {
    return _then(_$_Meta(
      total_count: null == total_count
          ? _value.total_count
          : total_count // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Meta implements _Meta {
  _$_Meta({required this.total_count});

  factory _$_Meta.fromJson(Map<String, dynamic> json) => _$$_MetaFromJson(json);

  @override
  final int total_count;

  @override
  String toString() {
    return 'Meta(total_count: $total_count)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Meta &&
            (identical(other.total_count, total_count) ||
                other.total_count == total_count));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, total_count);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MetaCopyWith<_$_Meta> get copyWith =>
      __$$_MetaCopyWithImpl<_$_Meta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MetaToJson(
      this,
    );
  }
}

abstract class _Meta implements Meta {
  factory _Meta({required final int total_count}) = _$_Meta;

  factory _Meta.fromJson(Map<String, dynamic> json) = _$_Meta.fromJson;

  @override
  int get total_count;
  @override
  @JsonKey(ignore: true)
  _$$_MetaCopyWith<_$_Meta> get copyWith => throw _privateConstructorUsedError;
}

KakaoAddress _$KakaoAddressFromJson(Map<String, dynamic> json) {
  return _KakaoAddress.fromJson(json);
}

/// @nodoc
mixin _$KakaoAddress {
  Meta get meta => throw _privateConstructorUsedError;
  Document get documents => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KakaoAddressCopyWith<KakaoAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KakaoAddressCopyWith<$Res> {
  factory $KakaoAddressCopyWith(
          KakaoAddress value, $Res Function(KakaoAddress) then) =
      _$KakaoAddressCopyWithImpl<$Res, KakaoAddress>;
  @useResult
  $Res call({Meta meta, Document documents});

  $MetaCopyWith<$Res> get meta;
  $DocumentCopyWith<$Res> get documents;
}

/// @nodoc
class _$KakaoAddressCopyWithImpl<$Res, $Val extends KakaoAddress>
    implements $KakaoAddressCopyWith<$Res> {
  _$KakaoAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? meta = null,
    Object? documents = null,
  }) {
    return _then(_value.copyWith(
      meta: null == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta,
      documents: null == documents
          ? _value.documents
          : documents // ignore: cast_nullable_to_non_nullable
              as Document,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res> get meta {
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DocumentCopyWith<$Res> get documents {
    return $DocumentCopyWith<$Res>(_value.documents, (value) {
      return _then(_value.copyWith(documents: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_KakaoAddressCopyWith<$Res>
    implements $KakaoAddressCopyWith<$Res> {
  factory _$$_KakaoAddressCopyWith(
          _$_KakaoAddress value, $Res Function(_$_KakaoAddress) then) =
      __$$_KakaoAddressCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Meta meta, Document documents});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $DocumentCopyWith<$Res> get documents;
}

/// @nodoc
class __$$_KakaoAddressCopyWithImpl<$Res>
    extends _$KakaoAddressCopyWithImpl<$Res, _$_KakaoAddress>
    implements _$$_KakaoAddressCopyWith<$Res> {
  __$$_KakaoAddressCopyWithImpl(
      _$_KakaoAddress _value, $Res Function(_$_KakaoAddress) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? meta = null,
    Object? documents = null,
  }) {
    return _then(_$_KakaoAddress(
      meta: null == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta,
      documents: null == documents
          ? _value.documents
          : documents // ignore: cast_nullable_to_non_nullable
              as Document,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_KakaoAddress implements _KakaoAddress {
  _$_KakaoAddress({required this.meta, required this.documents});

  factory _$_KakaoAddress.fromJson(Map<String, dynamic> json) =>
      _$$_KakaoAddressFromJson(json);

  @override
  final Meta meta;
  @override
  final Document documents;

  @override
  String toString() {
    return 'KakaoAddress(meta: $meta, documents: $documents)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_KakaoAddress &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.documents, documents) ||
                other.documents == documents));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, meta, documents);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_KakaoAddressCopyWith<_$_KakaoAddress> get copyWith =>
      __$$_KakaoAddressCopyWithImpl<_$_KakaoAddress>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_KakaoAddressToJson(
      this,
    );
  }
}

abstract class _KakaoAddress implements KakaoAddress {
  factory _KakaoAddress(
      {required final Meta meta,
      required final Document documents}) = _$_KakaoAddress;

  factory _KakaoAddress.fromJson(Map<String, dynamic> json) =
      _$_KakaoAddress.fromJson;

  @override
  Meta get meta;
  @override
  Document get documents;
  @override
  @JsonKey(ignore: true)
  _$$_KakaoAddressCopyWith<_$_KakaoAddress> get copyWith =>
      throw _privateConstructorUsedError;
}
